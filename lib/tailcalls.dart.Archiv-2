abstract class TailRec<A> {
  A value;

  //A result();

  /*
    @annotation.tailrec final def result: A = this match {
      case Done(a:A) => a
      case Call(t) => t().result
      case Cont(a, f) => a match {
        case Done(v) => f(v).result
        case Call(t) => t().flatMap(f).result
        case Cont(b, g) => b.flatMap(x => g(x) (flatMap) f).result
      }
    }
  */

  A result() {
    TailRec<A> tr = this;

    while (!(tr is _Done<A>)) {
      // this
      // Bounce
      if (tr is _Bounce<A>) {
        tr = (tr as _Bounce<A>).continuation();

        // Cont
      } else if (tr is Cont) {
        TailRec a = (tr as Cont).a;
        TailRec<A> Function(A) f = (tr as Cont<A, A>).f;

        /// TODO

        // a
        // Done
        if (a is _Done<A>) {
          tr = f(a.value);
          // Bounce
        } else if (a is _Bounce) {
          tr = ((a as _Bounce<A>).continuation().flatMap<A>(f));
          // Cont
        } else if (a is Cont) {
          TailRec<A> b = a.a as TailRec<A>;
          TailRec<A> Function(A) g = a.f as TailRec<A> Function(A);
          tr = b.flatMap<A>((x) => g(x).flatMap<A>(f));
        }
      }
    }
    return tr.value;
  }

  /*
  A result<C>() {
    TailRec<A> tr = this;

    while (!(tr is _Done<A>)) {
      // this
      // Bounce
      if (tr is _Bounce<A>) {
        tr = (tr as _Bounce<A>).continuation();

        // Cont
      } else if (tr is Cont<C,A>) {
        TailRec<C> a = (tr as Cont<C,A>).a;
        TailRec<A> Function(C) f = (tr as Cont<C,A>).f; /// TODO

        // a
        // Done
        if (a is _Done<C>) {
          tr = f((a ).value);
          // Bounce
        } else if (a is _Bounce<C>) {
          tr = ((a).continuation().flatMap<A>(f));
          // Cont
        } else if (a is Cont<C,A>) {
          TailRec<A> b = (a as Cont<C,A>).a as TailRec<A>;
          TailRec<A> Function(C) g = (a as Cont<C,A>).f ;
          tr = b.flatMap<A>((x) => g(x).flatMap<A>(f));
        }
      }
    }
    return tr.value;
  }
  */

  // final def map[B](f: A => B): TailRec[B] =  flatMap(a => Call(() => Done(f(a))))

  TailRec<B> map<B>(B Function(A) f) {
    return flatMap<B>((a) => _Bounce<B>(() => _Done<B>(f(a))));
  }

  TailRec<B> flatMap<B>(TailRec<B> Function(A) f);
}

///
/// Continuation
///
class Cont<A, B> extends TailRec<B> {
  Cont(this.a, this.f);
  //
  final TailRec<A> a;
  final TailRec<B> Function(A x) f;

  /*   
  @override
  B result() {
    Cont<A, B> tr = this;
   
    // redundant: man kann statt this.f gleich f schreiben.
    TailRec<B> Function(A) f = this.f;

    // a
    // Done
    if (this.a is _Done<A>) {
      return f((this.a).value).value;
      // Bounce
    } else if (this.a is _Bounce<A>) {
      return ((this.a as _Bounce<A> ).continuation().flatMap<B>(f)).value;
      // Cont
    } else if (this.a is Cont<A, B>) {
      TailRec<A> b = (this.a as Cont<A, B>).a;
      TailRec<A> Function(A) g = (a as Cont<A, B>).f as TailRec<A> Function(A);
      tr = b.flatMap<B>((x) => g(x).flatMap<B>(f)) as Cont<A, B>;
    }

    return tr.value;
  }
  */
  @override
  TailRec<C> flatMap<C>(TailRec<C> Function(B) f) =>
      Cont<A, C>(this.a, (A x) => this.f(x).flatMap<C>(f));
}

///
/// _Done
///

class _Done<A> extends TailRec<A> {
  _Done(this.value);
/*
  @override
  A result() => this.value;
*/
  @override
  TailRec<B> flatMap<B>(TailRec<B> Function(A) f) =>
      _Bounce<B>(() => f(this.value));

  @override
  final A value;
}

//
/// _Bounce
///

class _Bounce<A> extends TailRec<A> {
  _Bounce(this.continuation);

  TailRec<A> Function() continuation;
/*
  @override
  A result() {
    return this.continuation().value;
  }
*/
  @override
  TailRec<B> flatMap<B>(TailRec<B> Function(A) f) => Cont<A, B>(this, f);
}

//
/// done
///

TailRec<A> done<A>(A x) => _Done<A>(x);

//
/// tailcall
///

TailRec<A> tailcall<A>(TailRec<A> continuation()) => _Bounce<A>(continuation);

// -------------------------------------------------

class Defs {
  ///
  static TailRec<bool> odd(int n) =>
      n == 0 ? done(false) : tailcall(() => even(n - 1));
  static TailRec<bool> even(int n) =>
      n == 0 ? done(true) : tailcall(() => odd(n - 1));

  ///
  static bool badodd(int n) => n == 0 ? false : badeven(n - 1);
  static bool badeven(int n) => n == 0 ? true : badodd(n - 1);

  ///
  static TailRec<int> fib(int n) {
    if (n < 2) {
      return done<int>(n);
    } else {
      return tailcall<int>(() => fib(n - 1)).flatMap<int>((x) {
        return tailcall<int>(() => fib(n - 2)).map<int>((y) {
          return (x + y);
        });
      });
    }
  }
}

void main() {
  bool res1;
  int z = 12500;
  res1 = (Defs.even(z).result());

  print("Ergebnis von Odd/Even ist $res1");
  // res1 = (Defs.badeven(z)); // int z = 12500; geht noch.
  // print("Ergebnis von bad Odd/Even ist $res1");
  num res2;
  res2 = Defs.fib(14).result();
  print("Ergebnis von Fibonacci ist $res2");
}
