// diese Version sollte es eigentlich sein.


abstract class TailRec<A> {
  A value;

  A result() {
    TailRec<A> tr = this;
    while (!(tr is _Done<A>)) {
      if (tr is _Bounce<A>) {
        tr = (tr as _Bounce<A>).continuation();
      } else if (tr is Cont) {
        TailRec a = (tr as Cont).a;
        var f = (tr as Cont).f;
        if (a is _Done<A>) {
          tr = f(a.value) as TailRec<A>;
        } else if (a is _Bounce<A>) {
          tr = a.continuation().flatMap<A>(f as TailRec<A> Function(A));
        } else if (a is Cont) {
          TailRec<A> b = a.a as TailRec<A>;
          TailRec<A> Function(A) g = a.f as TailRec<A> Function(A);
          tr = b.flatMap<A>(
              (A x) => g(x).flatMap<A>(f as TailRec<A> Function(A)));
        } else {
          throw Exception("#1");
        }
      } else {
        throw Exception("#2");
      }
    }
    return tr.value;
  }

  TailRec<B> map<B>(B Function(A) f) {
    return flatMap((a) => _Bounce(() => _Done<B>(f(a))));
  }

  TailRec<B> flatMap<B>(TailRec<B> Function(A) f);
}

class Cont<A, B> extends TailRec<B> {
  Cont(this.a, this.f);

  final TailRec<A> a;
  final TailRec<B> Function(A x) f;

  @override
  TailRec<C> flatMap<C>(TailRec<C> Function(B) f) =>
      Cont<A, C>(this.a, (A x) => this.f(x).flatMap(f));
}

class _Done<A> extends TailRec<A> {
  _Done(this.value);

  @override
  TailRec<B> flatMap<B>(TailRec<B> Function(A) f) =>
      _Bounce(() => f(this.value));

  @override
  final A value;
}

class _Bounce<A> extends TailRec<A> {
  _Bounce(this.continuation);

  TailRec<A> Function() continuation;

  @override
  TailRec<B> flatMap<B>(TailRec<B> Function(A) f) => Cont(this, f);
}

//
/// done
///

TailRec<A> done<A>(A x) => _Done<A>(x);

//
/// tailcall
///

TailRec<A> tailcall<A>(TailRec<A> continuation()) => _Bounce<A>(continuation);


//+++++++++++++++++++++++++++


class Defs {
  ///
  static TailRec<bool> odd(int n) => n == 0 ? done(false) : tailcall(() => even(n - 1));
  static TailRec<bool> even(int n) => n == 0 ? done(true) : tailcall(() => odd(n - 1));

  ///
  static bool badodd(int n) => n == 0 ? false : badeven(n - 1);
  static bool badeven(int n) => n == 0 ? true : badodd(n - 1);

  ///
  static TailRec<int> fib(int n) {
    if (n < 2) {
      return done<int>(n);
    } else {
      return tailcall<int>(() => fib(n - 1)).flatMap<int>((x) {
        return tailcall<int>(() => fib(n - 2)).map<int>((y) {
          return (x + y);
        });
      });
    }
  }
}

void main() {
  bool res1;
  res1 = (Defs.even(101).result());
  print("Ergebnis von Odd/Even ist $res1");
  num res2;
  res2 = Defs.fib(14).result();
  print("Ergebnis von Fibonacci ist $res2");
}
